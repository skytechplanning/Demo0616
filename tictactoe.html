<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>○×ゲーム</title>
<style>
  body { text-align: center; font-family: sans-serif; background: #f0f0f0; }
  canvas { background: #fff; border: 1px solid #000; margin-top: 20px; }
  button { margin-top: 20px; padding: 10px 20px; font-size: 16px; }
  #message { margin-top: 20px; font-size: 20px; }
</style>
</head>
<body>
<h1>○×ゲーム</h1>
<canvas id="game" width="300" height="300"></canvas>
<div id="message"></div>
<button id="restart" style="display:none;">もう一度プレイ</button>
<script>
// --- ゲーム設定 ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const SIZE = 100; // 1マスのサイズ
let board = Array(9).fill(null); // 盤面データ
let gameOver = false;

// 勝利パターン
const LINES = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8], // 横
  [0, 3, 6], [1, 4, 7], [2, 5, 8], // 縦
  [0, 4, 8], [2, 4, 6]            // 斜め
];

drawBoard();

canvas.addEventListener('click', handleClick);
document.getElementById('restart').addEventListener('click', resetGame);

// --- 盤面を描画 ---
function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // グリッド線
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  for (let i = 1; i <= 2; i++) {
    ctx.beginPath();
    ctx.moveTo(i * SIZE, 0);
    ctx.lineTo(i * SIZE, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, i * SIZE);
    ctx.lineTo(canvas.width, i * SIZE);
    ctx.stroke();
  }
  drawMarks();
}

// --- マスに○×を描画 ---
function drawMarks() {
  ctx.font = '80px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for (let i = 0; i < board.length; i++) {
    const mark = board[i];
    if (mark) {
      const x = (i % 3) * SIZE + SIZE / 2;
      const y = Math.floor(i / 3) * SIZE + SIZE / 2;
      ctx.fillText(mark, x, y);
    }
  }
}

// --- クリック時の処理 ---
function handleClick(e) {
  if (gameOver) return; // ゲーム終了時は無視
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const col = Math.floor(x / SIZE);
  const row = Math.floor(y / SIZE);
  const idx = row * 3 + col;
  if (board[idx]) return; // すでに置かれている

  board[idx] = '○';
  drawBoard();

  if (checkWin('○')) {
    endGame('○の勝ち！');
    return;
  }
  if (isDraw()) {
    endGame('引き分け');
    return;
  }

  cpuMove();
}

// --- CPUの行動ロジック ---
function cpuMove() {
  const best = findBestMove();
  if (best !== null) {
    board[best] = '×';
  }
  drawBoard();

  if (checkWin('×')) {
    endGame('×の勝ち！');
    return;
  }
  if (isDraw()) {
    endGame('引き分け');
  }
}

// --- CPUが打つ場所を決める ---
function findBestMove() {
  // 1. 自分が勝てる手を探す
  for (let i = 0; i < board.length; i++) {
    if (!board[i]) {
      board[i] = '×';
      if (checkWin('×')) { board[i] = null; return i; }
      board[i] = null;
    }
  }
  // 2. 相手が勝ちそうなら阻止
  for (let i = 0; i < board.length; i++) {
    if (!board[i]) {
      board[i] = '○';
      if (checkWin('○')) { board[i] = null; return i; }
      board[i] = null;
    }
  }
  // 3. 中央を取る
  if (!board[4]) return 4;
  // 4. 角を優先
  const corners = [0, 2, 6, 8];
  const freeCorners = corners.filter(i => !board[i]);
  if (freeCorners.length) return freeCorners[Math.floor(Math.random() * freeCorners.length)];
  // 5. その他の空いている場所
  const free = board.map((v, i) => v ? null : i).filter(v => v !== null);
  if (free.length) return free[Math.floor(Math.random() * free.length)];
  return null;
}

// --- 勝敗判定 ---
function checkWin(mark) {
  return LINES.some(line => line.every(i => board[i] === mark));
}

function isDraw() {
  return board.every(cell => cell);
}

function endGame(msg) {
  gameOver = true;
  document.getElementById('message').textContent = msg;
  document.getElementById('restart').style.display = 'inline-block';
}

function resetGame() {
  board = Array(9).fill(null);
  gameOver = false;
  document.getElementById('message').textContent = '';
  document.getElementById('restart').style.display = 'none';
  drawBoard();
}
</script>
</body>
</html>
