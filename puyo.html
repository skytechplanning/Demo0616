<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ぷよぷよ風ゲーム</title>
<style>
  body { background: #222; color: #fff; text-align: center; }
  canvas { background: #000; margin-top: 20px; }
</style>
</head>
<body>
<h1>簡易ぷよぷよ</h1>
<canvas id="game" width="180" height="360"></canvas>
<script>
// ----- 設定 -----
const COLS = 6;
const ROWS = 12;
const SIZE = 30; // 1マスの大きさ
const COLORS = ['red', 'blue', 'green', 'yellow'];
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ----- ボード初期化 -----
const board = Array.from({length: ROWS}, () => Array(COLS).fill(null));

// 落下中の2つ1組のぷよ
let pair = null;
let dropInterval = 500; // ミリ秒
let dropCounter = 0;
let lastTime = 0;

// ----- ペア生成 -----
function spawnPair() {
  const c1 = COLORS[Math.floor(Math.random() * COLORS.length)];
  const c2 = COLORS[Math.floor(Math.random() * COLORS.length)];
  pair = {
    x: Math.floor(COLS / 2),
    y: -1, // 画面外から開始
    dir: 0, // 向き 0:上 1:右 2:下 3:左
    colors: [c1, c2]
  };
}

// ----- ペアの各ぷよ位置計算 -----
function pairCells(p) {
  const cells = [{x:p.x, y:p.y, color:p.colors[0]}];
  if (p.dir === 0) cells.push({x:p.x, y:p.y-1, color:p.colors[1]});
  else if (p.dir === 1) cells.push({x:p.x+1, y:p.y, color:p.colors[1]});
  else if (p.dir === 2) cells.push({x:p.x, y:p.y+1, color:p.colors[1]});
  else if (p.dir === 3) cells.push({x:p.x-1, y:p.y, color:p.colors[1]});
  return cells;
}

// ----- 衝突判定 -----
function collide(p) {
  const cells = pairCells(p);
  for (const c of cells) {
    if (c.x < 0 || c.x >= COLS || c.y >= ROWS) return true;
    if (c.y >= 0 && board[c.y][c.x]) return true;
  }
  return false;
}

// ----- ペアをボードに固定 -----
function merge(p) {
  const cells = pairCells(p);
  for (const c of cells) {
    if (c.y >= 0) board[c.y][c.x] = c.color;
  }
}

// ----- 4連消しチェック -----
function sweep() {
  const visited = Array.from({length: ROWS}, () => Array(COLS).fill(false));
  let erased = false;
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const color = board[y][x];
      if (!color || visited[y][x]) continue;
      const stack = [{x,y}];
      const group = [];
      visited[y][x] = true;
      while (stack.length) {
        const {x:cx, y:cy} = stack.pop();
        group.push({x:cx, y:cy});
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dx,dy] of dirs) {
          const nx = cx+dx, ny = cy+dy;
          if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !visited[ny][nx] && board[ny][nx]===color) {
            visited[ny][nx] = true;
            stack.push({x:nx,y:ny});
          }
        }
      }
      if (group.length >= 4) {
        for (const g of group) board[g.y][g.x] = null;
        erased = true;
      }
    }
  }
  return erased;
}

// ----- 重力処理 -----
function applyGravity() {
  for (let x = 0; x < COLS; x++) {
    for (let y = ROWS - 1; y >= 0; y--) {
      if (!board[y][x]) {
        let ny = y - 1;
        while (ny >= 0 && !board[ny][x]) ny--;
        if (ny >= 0) {
          board[y][x] = board[ny][x];
          board[ny][x] = null;
        }
      }
    }
  }
}

// ----- 描画 -----
function drawCell(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x*SIZE, y*SIZE, SIZE-1, SIZE-1);
}

function draw() {
  ctx.clearRect(0,0,canvas.width, canvas.height);
  // ボードのぷよ
  for (let y=0; y<ROWS; y++) {
    for (let x=0; x<COLS; x++) {
      const c = board[y][x];
      if (c) drawCell(x,y,c);
    }
  }
  // 落下中のぷよ
  if (pair) {
    const cells = pairCells(pair);
    for (const c of cells) {
      if (c.y>=0) drawCell(c.x, c.y, c.color);
    }
  }
}

// ----- 更新ループ -----
function update(time=0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval) {
    pair.y++;
    if (collide(pair)) {
      pair.y--;
      merge(pair);
      if (sweep()) applyGravity();
      spawnPair();
      if (collide(pair)) { // ゲームオーバー
        board.forEach(r => r.fill(null));
      }
    }
    dropCounter = 0;
  }
  draw();
  requestAnimationFrame(update);
}

// ----- キー操作 -----
document.addEventListener('keydown', e => {
  if (!pair) return;
  if (e.key === 'ArrowLeft') {
    pair.x--; if (collide(pair)) pair.x++;
  } else if (e.key === 'ArrowRight') {
    pair.x++; if (collide(pair)) pair.x--;
  } else if (e.key === 'ArrowDown') {
    pair.y++; if (collide(pair)) { pair.y--; }
  } else if (e.key === 'ArrowUp') {
    const old = pair.dir;
    pair.dir = (pair.dir + 1) % 4;
    if (collide(pair)) pair.dir = old;
  }
});

spawnPair();
requestAnimationFrame(update);
</script>
</body>
</html>
